#!/usr/bin/env python3
"""
OBS Package Update Script for Himmelblau

Submits updates of the latest stable branch to openSUSE Build Service.
Creates a branch, updates the package using osc service, regenerates the spec file,
attempts to build, and provides AI-assisted debugging if the build fails.

Usage:
  python scripts/obs_update.py [--ai-provider gemini|claude] [--dry-run]
  python scripts/obs_update.py --target tumbleweed --branch stable-2.x
"""

import argparse
import os
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Optional

# Configuration
DEFAULT_OBS_PROJECT = "network:idm"
DEFAULT_OBS_PACKAGE = "himmelblau"
DEFAULT_STABLE_BRANCH = "stable-2.x"
DEFAULT_TARGET = "tumbleweed"

TIMEOUT_OSC_SECONDS = 300  # 5 minutes for osc operations
TIMEOUT_BUILD_SECONDS = 1800  # 30 minutes for builds
MAX_BUILD_FIX_ATTEMPTS = 15


def print_color(text: str, color: str):
    """Print colored text to terminal."""
    colors = {
        'red': '\033[91m',
        'green': '\033[92m',
        'yellow': '\033[93m',
        'blue': '\033[94m',
        'magenta': '\033[95m',
        'cyan': '\033[96m',
        'white': '\033[97m',
        'reset': '\033[0m',
        'bold': '\033[1m',
    }
    print(f"{colors.get(color, '')}{text}{colors['reset']}")


def run_cmd(cmd: list[str], cwd: Optional[Path] = None, timeout: int = 120,
            capture: bool = True, check: bool = True) -> subprocess.CompletedProcess:
    """Run a command with timeout and error handling."""
    try:
        if capture:
            result = subprocess.run(
                cmd, cwd=cwd, capture_output=True, text=True,
                timeout=timeout, check=check
            )
        else:
            result = subprocess.run(
                cmd, cwd=cwd, timeout=timeout, check=check
            )
        return result
    except subprocess.TimeoutExpired:
        print_color(f"Command timed out: {' '.join(cmd)}", "red")
        raise
    except subprocess.CalledProcessError as e:
        if capture:
            print_color(f"Command failed: {' '.join(cmd)}", "red")
            if e.stdout:
                print(f"stdout: {e.stdout}")
            if e.stderr:
                print(f"stderr: {e.stderr}")
        raise


class AIRunner:
    """Run AI CLI for build fixes."""

    FIX_BUILD_PROMPT = """I'm updating an OBS (openSUSE Build Service) package and the build is failing.

## Package Information
- OBS Project: {obs_project}
- Package: {obs_package}
- Target Distribution: {target}
- Source Branch: {source_branch}

## Build Error
```
{build_error}
```

## Working Directory
The OBS package checkout is in: {work_dir}

Key files:
- himmelblau.spec - The RPM spec file
- himmelblau.changes - The changelog file
- _service - OBS service definition

## Useful Commands
- `osc diff` - Show what changes have been made to the package
- `osc status` - Show file status (modified, added, deleted)
- `osc build openSUSE_Tumbleweed x86_64` - Rebuild locally

## Your Task
1. Run `osc diff` to understand what changes were made
2. Analyze the build error
3. Identify what needs to be fixed
4. Make the necessary changes to fix the build

Common issues:
- Missing BuildRequires dependencies
- Spec file syntax errors
- Version mismatches
- Missing source files
- Macro expansion issues

Please investigate the error and apply fixes. Focus on making minimal changes
to get the build working.

When done, use /exit to return to the script.
"""

    REVIEW_SPEC_DIFF_PROMPT = """I've been updating an OBS package and the build required manual fixes to the spec file.

## Context
- Source Branch: {source_branch}
- Target Distribution: {target}
- The spec file was generated by `scripts/gen_rpm_spec.py` in the main branch
- The spec was generated against the {source_branch} branch's Cargo.toml files
- Manual fixes were needed to make the build succeed

## Original Generated Spec (before fixes)
```
{original_spec}
```

## Current Spec (after fixes)
```
{fixed_spec}
```

## Diff (what changed)
```diff
{spec_diff}
```

## Repository Location
The main himmelblau repository is at: {repo_root}

Key files:
- scripts/gen_rpm_spec.py - The spec file generator script
- scripts/gen_dockerfiles.py - Build dependency definitions (imported by gen_rpm_spec.py)

## Your Task
1. Analyze the diff to understand what fixes were needed
2. Determine if these fixes should be incorporated into `gen_rpm_spec.py`
3. If changes are needed, modify `scripts/gen_rpm_spec.py` to generate the correct spec

## Important Considerations
- The gen_rpm_spec.py script must remain **backwards compatible** with older stable branches
- Consider using conditionals if fixes are version-specific
- Some fixes may be one-off issues that shouldn't change the generator
- Focus on systematic issues that would affect future spec generations

Please review the diff and make any necessary improvements to gen_rpm_spec.py.
If no changes are needed (the fix was a one-off), explain why and use /exit.

When done, use /exit to return to the script.
"""

    def __init__(self, provider: str, cli_path: Optional[str] = None):
        self.provider = provider
        self.cli_path = cli_path or provider

    def is_available(self) -> bool:
        """Check if the AI CLI is available."""
        return shutil.which(self.cli_path) is not None

    def fix_build_interactive(
        self,
        obs_project: str,
        obs_package: str,
        target: str,
        source_branch: str,
        build_error: str,
        work_dir: Path,
    ) -> bool:
        """Launch AI CLI to fix build issues interactively."""
        prompt = self.FIX_BUILD_PROMPT.format(
            obs_project=obs_project,
            obs_package=obs_package,
            target=target,
            source_branch=source_branch,
            build_error=build_error,
            work_dir=work_dir,
        )

        print_color(f"\nLaunching {self.provider} CLI to fix build...", "green")
        print_color("The AI will start with context about the build error.", "yellow")
        print_color("Use /exit, Ctrl+C, or Ctrl+D to exit when done.\n", "yellow")

        try:
            # Change to the work directory and launch AI
            subprocess.run([self.cli_path, prompt], cwd=work_dir)
            return True
        except KeyboardInterrupt:
            print("\n")
            return True
        except FileNotFoundError:
            print_color(f"Error: {self.provider} CLI not found at '{self.cli_path}'", "red")
            return False
        except Exception as e:
            print_color(f"Error running {self.provider}: {e}", "red")
            return False

    def review_spec_diff_interactive(
        self,
        source_branch: str,
        target: str,
        original_spec: str,
        fixed_spec: str,
        spec_diff: str,
        repo_root: Path,
    ) -> bool:
        """Launch AI CLI to review spec diff and suggest gen_rpm_spec.py patches."""
        prompt = self.REVIEW_SPEC_DIFF_PROMPT.format(
            source_branch=source_branch,
            target=target,
            original_spec=original_spec,
            fixed_spec=fixed_spec,
            spec_diff=spec_diff,
            repo_root=repo_root,
        )

        print_color(f"\nLaunching {self.provider} CLI to review spec changes...", "green")
        print_color("The AI will analyze changes and may update gen_rpm_spec.py.", "yellow")
        print_color("Use /exit, Ctrl+C, or Ctrl+D to exit when done.\n", "yellow")

        try:
            # Run in the main repo root so AI can edit gen_rpm_spec.py
            subprocess.run([self.cli_path, prompt], cwd=repo_root)
            return True
        except KeyboardInterrupt:
            print("\n")
            return True
        except FileNotFoundError:
            print_color(f"Error: {self.provider} CLI not found at '{self.cli_path}'", "red")
            return False
        except Exception as e:
            print_color(f"Error running {self.provider}: {e}", "red")
            return False


class OBSManager:
    """Manages OBS package updates."""

    def __init__(
        self,
        obs_project: str,
        obs_package: str,
        source_branch: str,
        target: str,
        repo_root: Path,
        ai: AIRunner,
        dry_run: bool = False,
    ):
        self.obs_project = obs_project
        self.obs_package = obs_package
        self.source_branch = source_branch
        self.target = target
        self.repo_root = repo_root
        self.ai = ai
        self.dry_run = dry_run
        self.work_dir: Optional[Path] = None
        self.branch_project: Optional[str] = None
        self.original_spec_content: Optional[str] = None  # Track original generated spec

    def check_prerequisites(self) -> bool:
        """Check that required tools are available."""
        if not shutil.which("osc"):
            print_color("Error: osc is not installed", "red")
            print("Install with: zypper install osc")
            return False

        # Check osc is configured by trying to list user info
        try:
            # Use 'osc whois' to check login status
            result = run_cmd(["osc", "whois"], timeout=30, check=False)
            if result.returncode != 0:
                # Try alternative: list a known project
                run_cmd(["osc", "ls", self.obs_project], timeout=30)
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            print_color("Error: osc is not configured or not logged in", "red")
            print("Run: osc ls to trigger login")
            return False

        return True

    def get_username(self) -> Optional[str]:
        """Get the current OBS username."""
        try:
            # Try 'osc whois' first (shows current user info)
            result = run_cmd(["osc", "whois"], timeout=30, check=False)
            if result.returncode == 0 and result.stdout.strip():
                # Output format: "username: Real Name <email>"
                line = result.stdout.strip().split("\n")[0]
                if ":" in line:
                    return line.split(":")[0].strip()
                return line.split()[0].strip()
        except Exception:
            pass

        try:
            # Fallback: parse from oscrc config
            oscrc = Path.home() / ".config" / "osc" / "oscrc"
            if not oscrc.exists():
                oscrc = Path.home() / ".oscrc"
            if oscrc.exists():
                content = oscrc.read_text()
                for line in content.split("\n"):
                    if line.strip().startswith("user"):
                        parts = line.split("=")
                        if len(parts) >= 2:
                            return parts[1].strip()
        except Exception:
            pass

        return None

    def branch_package(self, work_base: Path) -> bool:
        """Branch the OBS package for editing."""
        print_color(f"\nBranching {self.obs_project}/{self.obs_package}...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would branch package", "yellow")
            return True

        try:
            # Branch the package (creates home:$USER:branches:$PROJECT/$PACKAGE)
            result = run_cmd(
                ["osc", "branch", self.obs_project, self.obs_package],
                timeout=TIMEOUT_OSC_SECONDS,
            )

            # Parse the branch project name from output
            # Output looks like: "A working copy of the branched package can be checked out with:
            # osc co home:username:branches:network:idm/himmelblau"
            output = result.stdout + result.stderr
            for line in output.split("\n"):
                if "osc co " in line or "osc checkout " in line:
                    parts = line.split()
                    for part in parts:
                        if "branches:" in part:
                            # Format: home:user:branches:network:idm/himmelblau
                            self.branch_project = part.split("/")[0]
                            break

            if not self.branch_project:
                # Try to construct it from username
                username = self.get_username()
                if username:
                    self.branch_project = f"home:{username}:branches:{self.obs_project}"

            print_color(f"  Branched to: {self.branch_project}", "green")

            # Checkout the branched package
            self.work_dir = work_base / self.obs_package
            run_cmd(
                ["osc", "checkout", self.branch_project, self.obs_package],
                cwd=work_base,
                timeout=TIMEOUT_OSC_SECONDS,
            )

            # The checkout creates: work_base/branch_project/package
            checkout_path = work_base / self.branch_project.replace(":", "_") / self.obs_package
            if checkout_path.exists():
                self.work_dir = checkout_path
            else:
                # Try alternate path format
                checkout_path = work_base / self.branch_project / self.obs_package
                if checkout_path.exists():
                    self.work_dir = checkout_path
                else:
                    # List what was created
                    print_color(f"  Looking for checkout in {work_base}...", "yellow")
                    for item in work_base.iterdir():
                        print(f"    {item}")
                        if item.is_dir():
                            for subitem in item.iterdir():
                                print(f"      {subitem}")
                                if subitem.name == self.obs_package:
                                    self.work_dir = subitem
                                    break

            if not self.work_dir or not self.work_dir.exists():
                print_color("  Error: Could not find checkout directory", "red")
                return False

            print_color(f"  Checked out to: {self.work_dir}", "green")
            return True

        except subprocess.CalledProcessError as e:
            # Check if already branched
            if "already exists" in str(e.stderr):
                print_color("  Package already branched, checking out existing branch...", "yellow")
                username = self.get_username()
                if not username:
                    print_color("  Error: Could not determine OBS username", "red")
                    return False
                self.branch_project = f"home:{username}:branches:{self.obs_project}"

                self.work_dir = work_base / self.branch_project.replace(":", "_") / self.obs_package
                run_cmd(
                    ["osc", "checkout", self.branch_project, self.obs_package],
                    cwd=work_base,
                    timeout=TIMEOUT_OSC_SECONDS,
                )

                # Find the actual checkout path
                for item in work_base.iterdir():
                    if item.is_dir():
                        pkg_path = item / self.obs_package
                        if pkg_path.exists():
                            self.work_dir = pkg_path
                            break

                if self.work_dir and self.work_dir.exists():
                    print_color(f"  Checked out to: {self.work_dir}", "green")
                    return True

            print_color(f"  Failed to branch package: {e}", "red")
            return False

    def run_service(self) -> bool:
        """Run osc service to update the package sources."""
        if not self.work_dir:
            print_color("Error: No work directory set", "red")
            return False

        print_color("\nRunning osc service mr (manualrun)...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would run osc service mr", "yellow")
            return True

        try:
            # First, update the _service file to use the correct branch
            service_file = self.work_dir / "_service"
            if service_file.exists():
                content = service_file.read_text()
                # Update revision/branch parameter if present
                if "revision" in content or "branch" in content:
                    import re
                    # Replace revision parameter value
                    content = re.sub(
                        r'(<param name="revision">)[^<]*(</param>)',
                        rf'\g<1>{self.source_branch}\g<2>',
                        content
                    )
                    # Also update versionformat if it references a branch
                    content = re.sub(
                        r'(<param name="versionformat">)[^<]*(</param>)',
                        r'\g<1>@PARENT_TAG@+git@TAG_OFFSET@.%h\g<2>',
                        content
                    )
                    service_file.write_text(content)
                    print_color(f"  Updated _service to use branch: {self.source_branch}", "green")

            # Run the service
            result = run_cmd(
                ["osc", "service", "mr"],
                cwd=self.work_dir,
                timeout=TIMEOUT_OSC_SECONDS,
                capture=False,
                check=False,
            )

            if result.returncode != 0:
                print_color("  Warning: osc service mr returned non-zero", "yellow")

            print_color("  Service completed", "green")
            return True

        except subprocess.TimeoutExpired:
            print_color("  osc service mr timed out", "red")
            return False
        except Exception as e:
            print_color(f"  osc service mr failed: {e}", "red")
            return False

    def update_source_files(self) -> bool:
        """Handle tarball changes after osc service - remove old, add new."""
        if not self.work_dir:
            print_color("Error: No work directory set", "red")
            return False

        print_color("\nUpdating source files...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would update source files", "yellow")
            return True

        try:
            # Get current osc status to see what changed
            result = run_cmd(["osc", "status"], cwd=self.work_dir, timeout=60)
            status_output = result.stdout

            # Parse status output to find new and deleted files
            # Status format: "? newfile" for untracked, "! oldfile" for missing
            files_to_add = []
            files_to_remove = []

            for line in status_output.split("\n"):
                line = line.strip()
                if not line:
                    continue

                status_char = line[0] if line else ""
                filename = line[1:].strip() if len(line) > 1 else ""

                if status_char == "?" and filename:
                    # Untracked file - likely new tarball or vendor archive
                    files_to_add.append(filename)
                elif status_char == "!" and filename:
                    # Missing file - likely old tarball that was replaced
                    files_to_remove.append(filename)

            # Also check for .tar.bz2 and .tar.zst files specifically
            # The service may create new ones without marking old ones as missing
            existing_tarballs = set()
            for f in self.work_dir.iterdir():
                if f.name.endswith((".tar.bz2", ".tar.zst", ".tar.gz", ".tar.xz")):
                    existing_tarballs.add(f.name)

            # Remove old tarballs that aren't in the new set
            for line in status_output.split("\n"):
                if line.startswith("D "):
                    # Already marked for deletion
                    continue

            # Add new files
            if files_to_add:
                print_color(f"  Adding new files: {', '.join(files_to_add)}", "green")
                for f in files_to_add:
                    run_cmd(["osc", "add", f], cwd=self.work_dir, timeout=30)

            # Remove old/missing files
            if files_to_remove:
                print_color(f"  Removing old files: {', '.join(files_to_remove)}", "yellow")
                for f in files_to_remove:
                    run_cmd(["osc", "rm", "--force", f], cwd=self.work_dir, timeout=30, check=False)

            # Run osc addremove as a catch-all
            run_cmd(["osc", "addremove"], cwd=self.work_dir, timeout=60, check=False)

            # Show final status
            result = run_cmd(["osc", "status"], cwd=self.work_dir, timeout=60)
            if result.stdout.strip():
                print_color("  Updated files:", "blue")
                for line in result.stdout.strip().split("\n"):
                    print(f"    {line}")

            print_color("  Source files updated", "green")
            return True

        except Exception as e:
            print_color(f"  Failed to update source files: {e}", "red")
            return False

    def prepare_target_branch_checkout(self, work_base: Path) -> Optional[Path]:
        """
        Checkout the target branch to a temp location and copy latest scripts from main.

        This ensures we use the latest gen_rpm_spec.py from main, but generate
        the spec based on the target branch's Cargo.toml files.
        """
        print_color(f"\nPreparing {self.source_branch} checkout for spec generation...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would checkout target branch", "yellow")
            return self.repo_root  # Just use current repo in dry-run

        target_checkout = work_base / "himmelblau-target-branch"

        try:
            # Get the remote URL from current repo
            result = run_cmd(
                ["git", "remote", "get-url", "origin"],
                cwd=self.repo_root,
                timeout=30,
            )
            remote_url = result.stdout.strip()

            # Clone the target branch
            print_color(f"  Cloning {self.source_branch}...", "blue")
            run_cmd(
                [
                    "git", "clone",
                    "--depth", "1",
                    "--branch", self.source_branch,
                    remote_url,
                    str(target_checkout),
                ],
                timeout=TIMEOUT_OSC_SECONDS,
            )

            # Copy the latest scripts from main (current repo) to the target checkout
            print_color("  Copying latest scripts from main...", "blue")
            scripts_to_copy = [
                "gen_rpm_spec.py",
                "gen_dockerfiles.py",
                "gen_servicefiles.py",
            ]

            target_scripts_dir = target_checkout / "scripts"
            for script_name in scripts_to_copy:
                src = self.repo_root / "scripts" / script_name
                dst = target_scripts_dir / script_name
                if src.exists():
                    shutil.copy2(src, dst)
                    print_color(f"    Copied {script_name}", "green")

            print_color(f"  Target branch checkout ready: {target_checkout}", "green")
            return target_checkout

        except Exception as e:
            print_color(f"  Failed to prepare target branch checkout: {e}", "red")
            return None

    def regenerate_spec(self, target_checkout: Optional[Path] = None) -> bool:
        """Regenerate the spec file using gen_rpm_spec.py against target branch."""
        if not self.work_dir:
            print_color("Error: No work directory set", "red")
            return False

        print_color("\nRegenerating spec file...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would regenerate spec file", "yellow")
            return True

        # Use target branch checkout if provided, otherwise fall back to repo_root
        spec_root = target_checkout if target_checkout else self.repo_root

        try:
            gen_script = spec_root / "scripts" / "gen_rpm_spec.py"
            if not gen_script.exists():
                print_color(f"  Error: {gen_script} not found", "red")
                return False

            spec_file = self.work_dir / f"{self.obs_package}.spec"

            # Run the spec generator against the target branch
            print_color(f"  Running gen_rpm_spec.py against {spec_root}...", "blue")
            result = run_cmd(
                [
                    sys.executable, str(gen_script),
                    "--root", str(spec_root),
                    "--target", self.target,
                    "--output", str(spec_file),
                ],
                timeout=60,
            )

            # Save the original generated spec for later comparison
            if spec_file.exists():
                self.original_spec_content = spec_file.read_text()
                print_color(f"  Saved original spec for later comparison", "blue")

            print_color(f"  Generated: {spec_file}", "green")
            return True

        except Exception as e:
            print_color(f"  Failed to regenerate spec: {e}", "red")
            return False

    def try_build(self) -> tuple[bool, str]:
        """Try to build the package locally with osc build."""
        if not self.work_dir:
            return False, "No work directory set"

        print_color("\nAttempting local build...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would attempt local build", "yellow")
            return True, ""

        try:
            # Determine the repository and arch
            # Common repos: openSUSE_Tumbleweed, openSUSE_Leap_15.6, etc.
            repo = "openSUSE_Tumbleweed"
            if "leap" in self.target.lower():
                repo = f"openSUSE_Leap_{self.target.split('_')[-1]}"
            elif "sle" in self.target.lower():
                repo = f"SLE_{self.target.upper()}"

            # Run build with real-time output (not captured)
            # Use Popen to stream output while also capturing for error context
            cmd = ["osc", "build", "--no-verify", repo, "x86_64"]
            print_color(f"  Running: {' '.join(cmd)}", "blue")
            print_color("-" * 60, "cyan")

            output_lines: list[str] = []
            process = subprocess.Popen(
                cmd,
                cwd=self.work_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,  # Line buffered
            )

            # Stream output in real-time while capturing it
            try:
                for line in process.stdout:
                    print(line, end="")  # Print to terminal in real-time
                    output_lines.append(line)
                    # Keep only last 500 lines to avoid memory issues
                    if len(output_lines) > 500:
                        output_lines.pop(0)
            except KeyboardInterrupt:
                process.kill()
                print_color("\n  Build interrupted by user", "yellow")
                return False, "Build interrupted by user"

            process.wait(timeout=TIMEOUT_BUILD_SECONDS)
            print_color("-" * 60, "cyan")

            if process.returncode == 0:
                print_color("  Build succeeded!", "green")
                return True, ""
            else:
                # Get last 200 lines for error context
                error_output = "".join(output_lines[-200:])
                print_color("  Build failed", "red")
                return False, error_output

        except subprocess.TimeoutExpired:
            process.kill()
            return False, "Build timed out after 30 minutes"
        except Exception as e:
            return False, str(e)

    def review_spec_changes(self) -> bool:
        """
        Compare original generated spec with current spec after fixes.
        If different, launch AI to review and potentially update gen_rpm_spec.py.
        """
        if not self.work_dir:
            print_color("Error: No work directory set", "red")
            return False

        if not self.original_spec_content:
            print_color("\nNo original spec saved, skipping diff review", "yellow")
            return True

        print_color("\nChecking for spec file changes...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would check spec changes", "yellow")
            return True

        try:
            spec_file = self.work_dir / f"{self.obs_package}.spec"
            if not spec_file.exists():
                print_color("  Spec file not found, skipping diff review", "yellow")
                return True

            current_spec = spec_file.read_text()

            # Compare specs
            if current_spec == self.original_spec_content:
                print_color("  No changes to spec file - no review needed", "green")
                return True

            # Generate diff
            import difflib
            original_lines = self.original_spec_content.splitlines(keepends=True)
            current_lines = current_spec.splitlines(keepends=True)

            diff = list(difflib.unified_diff(
                original_lines,
                current_lines,
                fromfile="himmelblau.spec.original",
                tofile="himmelblau.spec.fixed",
            ))

            if not diff:
                print_color("  No meaningful changes to spec file", "green")
                return True

            diff_text = "".join(diff)
            print_color("  Spec file was modified during build fixes:", "yellow")
            print_color("-" * 60, "cyan")
            print(diff_text)
            print_color("-" * 60, "cyan")

            # Ask user if they want AI to review and update gen_rpm_spec.py
            print_color("\nThe spec file was modified to fix the build.", "yellow")
            print_color("Would you like AI to review these changes and potentially", "yellow")
            print_color("update gen_rpm_spec.py to prevent this issue in the future?", "yellow")

            try:
                response = input("\nReview and update gen_rpm_spec.py? [y/N]: ").strip().lower()
            except (KeyboardInterrupt, EOFError):
                print("\n")
                response = "n"

            if response in ("y", "yes"):
                if not self.ai.is_available():
                    print_color("AI CLI not available for review", "red")
                    return True

                self.ai.review_spec_diff_interactive(
                    source_branch=self.source_branch,
                    target=self.target,
                    original_spec=self.original_spec_content,
                    fixed_spec=current_spec,
                    spec_diff=diff_text,
                    repo_root=self.repo_root,
                )
            else:
                print_color("  Skipping gen_rpm_spec.py review", "blue")

            return True

        except Exception as e:
            print_color(f"  Failed to review spec changes: {e}", "red")
            return True  # Don't fail the whole process for this

    def commit_changes(self, message: str) -> bool:
        """Commit changes to the branched package."""
        if not self.work_dir:
            print_color("Error: No work directory set", "red")
            return False

        print_color("\nCommitting changes...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would commit changes", "yellow")
            return True

        try:
            # Add any new files
            run_cmd(["osc", "addremove"], cwd=self.work_dir, timeout=60, check=False)

            # Show status
            result = run_cmd(["osc", "status"], cwd=self.work_dir, timeout=60)
            if result.stdout.strip():
                print(f"  Changes:\n{result.stdout}")

            # Commit
            run_cmd(
                ["osc", "commit", "-m", message],
                cwd=self.work_dir,
                timeout=TIMEOUT_OSC_SECONDS,
                capture=False,
            )

            print_color("  Committed successfully", "green")
            return True

        except Exception as e:
            print_color(f"  Failed to commit: {e}", "red")
            return False

    def submit_request(self) -> bool:
        """Submit a request to merge changes to the original package."""
        if not self.work_dir or not self.branch_project:
            print_color("Error: No work directory or branch project set", "red")
            return False

        print_color("\nSubmitting merge request...", "blue")

        if self.dry_run:
            print_color("  (dry-run) Would submit merge request", "yellow")
            return True

        try:
            result = run_cmd(
                [
                    "osc", "submitrequest",
                    "--yes",  # Don't prompt
                    "-m", f"Update {self.obs_package} from {self.source_branch}",
                ],
                cwd=self.work_dir,
                timeout=TIMEOUT_OSC_SECONDS,
            )

            print_color("  Submit request created!", "green")
            print(result.stdout)
            return True

        except Exception as e:
            print_color(f"  Failed to submit request: {e}", "red")
            return False


def main():
    parser = argparse.ArgumentParser(
        description="Update Himmelblau package on openSUSE Build Service",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                              # Update from stable-2.x to network:idm
  %(prog)s --branch stable-2.x          # Specify branch explicitly
  %(prog)s --dry-run                    # Show what would be done
  %(prog)s --ai-provider gemini         # Use Gemini for build fixes
  %(prog)s --no-submit                  # Don't submit merge request
        """,
    )
    parser.add_argument(
        "--ai-provider",
        type=str,
        default="claude",
        choices=["claude", "gemini"],
        help="AI CLI to use for build fixes (default: claude)",
    )
    parser.add_argument(
        "--ai-provider-path",
        type=str,
        default=None,
        help="Path to the AI CLI binary",
    )
    parser.add_argument(
        "--project",
        type=str,
        default=DEFAULT_OBS_PROJECT,
        help=f"OBS project (default: {DEFAULT_OBS_PROJECT})",
    )
    parser.add_argument(
        "--package",
        type=str,
        default=DEFAULT_OBS_PACKAGE,
        help=f"OBS package name (default: {DEFAULT_OBS_PACKAGE})",
    )
    parser.add_argument(
        "--branch",
        type=str,
        default=DEFAULT_STABLE_BRANCH,
        help=f"Source git branch (default: {DEFAULT_STABLE_BRANCH})",
    )
    parser.add_argument(
        "--target",
        type=str,
        default=DEFAULT_TARGET,
        help=f"Target distribution for spec generation (default: {DEFAULT_TARGET})",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes",
    )
    parser.add_argument(
        "--no-submit",
        action="store_true",
        help="Don't submit merge request after building",
    )
    parser.add_argument(
        "--work-dir",
        type=Path,
        default=None,
        help="Working directory for OBS checkout (default: temp dir)",
    )

    args = parser.parse_args()

    # Determine repo root
    repo_root = Path(__file__).parent.parent.resolve()

    print_color("=" * 70, "cyan")
    print_color("  Himmelblau OBS Package Updater", "bold")
    print_color("=" * 70, "cyan")
    print()

    # Initialize AI runner with automatic fallback
    ai = AIRunner(args.ai_provider, args.ai_provider_path)

    # Check AI availability with fallback
    if not ai.is_available():
        # Try fallback to the other provider
        fallback_provider = "gemini" if args.ai_provider == "claude" else "claude"
        fallback_ai = AIRunner(fallback_provider)

        if fallback_ai.is_available():
            print_color(f"Note: {args.ai_provider} CLI not found, using {fallback_provider} instead", "yellow")
            ai = fallback_ai
        else:
            print_color(f"Warning: Neither claude nor gemini CLI available for build fixes", "yellow")
            print("Install Claude: npm install -g @anthropic-ai/claude-code")
            print("Install Gemini: See https://ai.google.dev/gemini-api/docs")

    # Create OBS manager
    manager = OBSManager(
        obs_project=args.project,
        obs_package=args.package,
        source_branch=args.branch,
        target=args.target,
        repo_root=repo_root,
        ai=ai,
        dry_run=args.dry_run,
    )

    # Check prerequisites
    if not manager.check_prerequisites():
        sys.exit(1)

    print_color(f"Project: {args.project}/{args.package}", "blue")
    print_color(f"Source branch: {args.branch}", "blue")
    print_color(f"Target: {args.target}", "blue")

    # Set up working directory
    if args.work_dir:
        work_base = args.work_dir
        work_base.mkdir(parents=True, exist_ok=True)
        cleanup_work_dir = False
    else:
        work_base = Path(tempfile.mkdtemp(prefix="obs-update-"))
        cleanup_work_dir = True

    print_color(f"Working directory: {work_base}", "blue")

    try:
        # Step 1: Branch the package
        if not manager.branch_package(work_base):
            print_color("\nFailed to branch package", "red")
            sys.exit(1)

        # Step 2: Prepare target branch checkout (for spec generation)
        # This clones the target branch and copies latest scripts from main
        target_checkout = manager.prepare_target_branch_checkout(work_base)
        if not target_checkout:
            print_color("\nFailed to prepare target branch checkout", "red")
            sys.exit(1)

        # Step 3: Regenerate spec file using target branch (BEFORE osc service)
        if not manager.regenerate_spec(target_checkout):
            print_color("\nFailed to regenerate spec file", "red")
            sys.exit(1)

        # Step 4: Run osc service to update sources
        if not manager.run_service():
            print_color("\nFailed to run osc service", "red")
            sys.exit(1)

        # Step 5: Handle tarball changes (osc rm old, osc add new)
        if not manager.update_source_files():
            print_color("\nFailed to update source files", "red")
            sys.exit(1)

        # Step 6: Try to build
        build_success, build_error = manager.try_build()
        attempt = 0

        while not build_success and attempt < MAX_BUILD_FIX_ATTEMPTS:
            attempt += 1
            print_color(f"\nBuild failed, attempt {attempt}/{MAX_BUILD_FIX_ATTEMPTS} to fix...", "yellow")

            if not ai.is_available():
                print_color("AI CLI not available, cannot auto-fix", "red")
                print_color("\nBuild error:", "yellow")
                print(build_error[-2000:])  # Last 2000 chars
                print_color(f"\nManually fix the build in: {manager.work_dir}", "yellow")
                try:
                    input("Press Enter when ready to retry build, or Ctrl+C to abort...")
                except (KeyboardInterrupt, EOFError):
                    print_color("\nAborted", "yellow")
                    sys.exit(1)
            else:
                if not ai.fix_build_interactive(
                    args.project,
                    args.package,
                    args.target,
                    args.branch,
                    build_error,
                    manager.work_dir,
                ):
                    print_color("AI fix session ended", "yellow")

            build_success, build_error = manager.try_build()

        if not build_success:
            print_color("\nCould not fix build after maximum attempts", "red")
            print_color(f"Working directory preserved at: {work_base}", "yellow")
            print_color("You can manually fix and run:", "yellow")
            print(f"  cd {manager.work_dir}")
            print("  osc build openSUSE_Tumbleweed x86_64")
            cleanup_work_dir = False
            sys.exit(1)

        print_color("\nBuild successful!", "green")

        # Step 7: Review spec changes and potentially update gen_rpm_spec.py
        manager.review_spec_changes()

        # Step 8: Commit changes
        if not manager.commit_changes(f"Update from {args.branch}"):
            print_color("\nFailed to commit changes", "red")
            sys.exit(1)

        # Step 9: Submit merge request
        if not args.no_submit:
            if not manager.submit_request():
                print_color("\nFailed to submit merge request", "red")
                print_color(f"You can manually submit from: {manager.work_dir}", "yellow")
                print("  osc submitrequest")
                cleanup_work_dir = False
                sys.exit(1)

        print_color("\n" + "=" * 70, "cyan")
        print_color("SUCCESS!", "bold")
        print_color("=" * 70, "cyan")
        print(f"Package updated and {'submitted' if not args.no_submit else 'committed'}.")
        if args.no_submit:
            print(f"\nTo submit, run:")
            print(f"  cd {manager.work_dir}")
            print(f"  osc submitrequest")

    finally:
        if cleanup_work_dir and work_base.exists():
            print_color(f"\nCleaning up {work_base}...", "blue")
            shutil.rmtree(work_base, ignore_errors=True)


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""
Himmelblau Dockerfile generator

Usage:
  python gen_dockerfiles.py [--out ./dockerfiles] [--only debian12,ubuntu22.04] [--arch amd64|arm64]

This follows a config-driven pattern inspired by Samba's bootstrap/config.py:
- deb family => cargo deb chain with per-package feature flags and --deb-revision=<distro>
- rpm/zypper family => cargo build + strip + cargo generate-rpm chain
- ebuild family => generates Gentoo ebuild file via gen_ebuild.py
"""

import argparse
import os
from pathlib import Path

# Architecture mapping
ARCH_MAP = {
    "amd64": {"docker_platform": "linux/amd64", "rpm_arch": "x86_64", "deb_arch": "amd64", "rust_target": "x86_64-unknown-linux-gnu"},
    "arm64": {"docker_platform": "linux/arm64", "rpm_arch": "aarch64", "deb_arch": "arm64", "rust_target": "aarch64-unknown-linux-gnu"},
}

GENERATED_MARKER = """\
#
# This file is generated by gen_dockerfiles.py
# Do not edit by hand — update the generator or config instead.
#

"""

# ---- Package config ----------------------------------------------------------

COMMON = [
    "git",
    "curl",
    "wget",
    "make",
    "pkg-config",
    "jq",
    "ca-certificates",
    "libtool",
    "autoconf",
    "gettext",
    "checkpolicy",
    "policycoreutils",
    "python3",
    "systemd",
]

PKG_PAIRS = [
    ("build-essential", "@development-tools"),
    ("gcc", "gcc"),
    ("g++", "gcc-c++"),
    ("libssl-dev", "openssl-devel"),
    ("libdbus-1-dev", "dbus-devel"),
    ("libkrb5-dev", "krb5-devel"),
    ("libpam0g-dev", "pam-devel"),
    ("libcap-dev", "libcap-devel"),
    ("libudev-dev", "libudev-devel"),
    ("cmake", "cmake"),
    ("libtss2-dev tpm-udev", "tpm2-tss-devel"),
    ("libclang-dev", "clang"),
    ("libpcre2-dev", "pcre2-devel"),
    ("libsqlite3-dev", "sqlite-devel"),
    ("libunistring-dev", "libunistring-devel"),
]

SELINUX_PKGS = ["policycoreutils-devel", "selinux-policy-targeted"]
AUTHSELECT_PKGS = ["authselect"]

DEB_PKGS = COMMON + [p for p, _ in PKG_PAIRS if p]
RPM_PKGS = COMMON + AUTHSELECT_PKGS + [q for _, q in PKG_PAIRS if q]

# enable caching of apt packages: https://docs.docker.com/build/cache/optimize/#use-cache-mounts
APT_BOOTSTRAP = """\
RUN rm -f /etc/apt/apt.conf.d/docker-clean; echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/keep-cache \n
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \\
    --mount=type=cache,target=/var/lib/apt,sharing=locked \\
    apt-get update && apt-get install -y \\\n    {pkgs} \\\n && rm -rf /var/lib/apt/lists/*\n"""

DNF_BOOTSTRAP = """\
RUN dnf -y update && dnf -y install \\\n    {pkgs} \\\n && dnf clean all\n"""

ZYPPER_BOOTSTRAP = """\
RUN zypper --non-interactive refresh && \\\n    zypper --non-interactive update && \\\n    zypper --non-interactive install --no-recommends \\\n        {pkgs} && \\\n    zypper clean --all\n"""

FAMILIES = {
    "deb": {
        "bootstrap": APT_BOOTSTRAP,
        "pkgs": DEB_PKGS,
        "env": "ENV DEBIAN_FRONTEND=noninteractive HIMMELBLAU_ALLOW_MISSING_SELINUX=1",
    },
    "rpm": {
        "bootstrap": DNF_BOOTSTRAP,
        "pkgs": RPM_PKGS,
        "env": None,
    },
    "zypper": {
        "bootstrap": ZYPPER_BOOTSTRAP,
        "pkgs": RPM_PKGS,
        "env": None,
    },
    "ebuild": {
        # Minimal bootstrap for ebuild generation - just needs Python (in base image)
        "bootstrap": "# No additional packages needed - Python is in the base image",
        "pkgs": [],
        "env": None,
    },
}

# ---- Final command builders --------------------------------------------------

PACKAGES = [
    # (crate name, crate source, needs_tpm_feature)
    ("himmelblaud", "src/daemon", True),
    ("nss_himmelblau", "src/nss", True),
    ("pam_himmelblau", "src/pam", True),
    ("sshd-config", "src/sshd-config", False),
    ("sso", "src/sso", True),
    ("sso-policies", "src/sso-policies", False),
    ("qr-greeter", "src/qr-greeter", False),
    ("selinux", "src/selinux", False),
    ("o365", "src/o365", False),
]

CMD_TAB = "     "
CMD_SEP = f" && \\ \n{CMD_TAB}"


GEN_MANPAGE = "python3 scripts/gen_param_code.py --gen-man --man-output man/man5/himmelblau.conf.5"


def build_deb_final_cmd(features: list, distro_slug: str, cross_target: str = "") -> str:
    target_arg = f" --target={cross_target}" if cross_target else ""
    parts = []
    for pkg, _, needs_tpm in PACKAGES:
        if pkg == "selinux":  # Debian doesn't use selinux
            continue
        # Copy the feature list per-package so that stripping "tpm" for a
        # package that doesn't need it (e.g. sshd-config) does not mutate the
        # shared list and accidentally drop the feature for subsequent packages
        # that DO need it (e.g. sso). Previously this was features.remove()
        # which permanently modified the caller's list mid-loop.
        pkg_features = list(features)
        if not needs_tpm:
            pkg_features = [f for f in pkg_features if f != "tpm"]
        feat_str = f" --features {','.join(pkg_features)}" if pkg_features else ""
        if "pam" in pkg or "nss" in pkg:
            feat_str += " --multiarch=same"
        parts.append(f"cargo deb ${{CARGO_PATCH_ARG}}{target_arg}{feat_str} --deb-revision={distro_slug} -p {pkg}")
    gen_servicefiles = "make deb-servicefiles"
    return f'CMD ["/bin/sh", "-c", \\\n{CMD_TAB}"{GEN_MANPAGE} && {gen_servicefiles} && {CMD_SEP.join(parts)} "]'


def build_rpm_final_cmd(features: list, selinux: bool) -> str:
    feat_str = f" --features {','.join(features)}" if features else ""
    build = f"cargo build ${{CARGO_PATCH_ARG}} --release{feat_str} && \\ \n{CMD_TAB}"
    strip = CMD_SEP.join(
        ["strip -s target/release/%s" % s for s in ["*.so", "aad-tool", "himmelblaud", "himmelblaud_tasks", "broker"]]
    )
    if selinux:
        pkgs = PACKAGES
    else:
        pkgs = [pkg for pkg in PACKAGES if pkg[0] != "selinux"]
    rpms = CMD_SEP.join([f"cargo generate-rpm -p {s}" for _, s, _ in pkgs])
    gen_servicefiles = "make rpm-servicefiles"
    gen_authselect = "(authselect select minimal --force || authselect select local --force) && make authselect"
    return f'CMD ["/bin/sh", "-c", \\\n{CMD_TAB}"{GEN_MANPAGE} && {gen_servicefiles} && {build}{strip} && {gen_authselect} && \\\n{CMD_TAB}{rpms}"]'


def build_gentoo_final_cmd(features: list, repo_root: Path) -> str:
    """Build command for Gentoo - generates an ebuild file."""
    return f'CMD ["/bin/sh", "-c", "{GEN_MANPAGE} && python3 scripts/gen_ebuild.py --out ./packaging/"]'


# ---- Distro targets ----------------------------------------------------------

DISTS = {
    # ---- Debian family ----
    "debian12": {
        "family": "deb",
        "image": "debian:12",
        "replace": {
            "@development-tools": "",
        },
        "tpm": True,
    },
    "debian13": {
        "family": "deb",
        "image": "debian:13",
        "replace": {
            "@development-tools": "",
        },
        "tpm": True,
    },
    "ubuntu22.04": {
        "family": "deb",
        "image": "ubuntu:22.04",
        "tpm": True,
    },
    "ubuntu24.04": {
        "family": "deb",
        "image": "ubuntu:24.04",
        "tpm": True,
    },
    "ubuntu25.10": {
        "family": "deb",
        "image": "ubuntu:25.10",
        "tpm": True,
    },
    "test": {
        "family": "deb",
        "image": "ubuntu:24.04",
        "tpm": False,
        "extra_pkgs": ["nodejs"],
    },
    # ---- Fedora family ----
    "fedora42": {
        "family": "rpm",
        "image": "fedora:42",
        "tpm": True,
        "selinux": True,
    },
    "fedora43": {
        "family": "rpm",
        "image": "fedora:43",
        "tpm": True,
        "selinux": True,
    },
    "rawhide": {
        "family": "rpm",
        "image": "fedora:rawhide",
        "extra_prep": [
            "RUN dnf -y --refresh update glibc glibc-common glibc-minimal-langpack systemd-libs systemd-standalone-sysusers rpm-libs rpm && dnf -y --refresh update"
        ],
        "tpm": True,
        "selinux": True,
    },
    # ---- Rocky family ----
    "rocky8": {
        "family": "rpm",
        "image": "rockylinux/rockylinux:8",
        "extra_prep": [
            "RUN dnf -y install 'dnf-command(config-manager)' && dnf config-manager --set-enabled powertools",
            # Python 3.6 doesn't have dataclasses; install python39 and use it
            "RUN dnf -y install python39 && alternatives --set python3 /usr/bin/python3.9",
        ],
        "replace": {
            "build-essential": '"@Development Tools"',
            "@development-tools": "",
        },
        "tpm": False,
        "selinux": True,
        "arm64": False,  # Rocky 8 is EOL, no aarch64 builds
    },
    "rocky9": {
        "family": "rpm",
        "image": "rockylinux/rockylinux:9",
        "extra_prep": [
            "RUN dnf -y install 'dnf-command(config-manager)' && dnf config-manager --set-enabled crb",
            "RUN sed -i -e 's|$rltype||g' /etc/yum.repos.d/rocky*.repo",
        ],
        "replace": {
            "build-essential": '"@Development Tools"',
            "@development-tools": "",
            "curl": "",  # avoid the curl/curl-minimal install conflict
        },
        "tpm": True,
        "selinux": True,
    },
    "rocky10": {
        "family": "rpm",
        "image": "rockylinux/rockylinux:10",
        "extra_prep": [
            "RUN dnf install -y 'dnf-command(config-manager)' && dnf config-manager --set-enabled crb",
            "RUN sed -i -e 's|$rltype||g' /etc/yum.repos.d/rocky*.repo",
        ],
        "replace": {
            "build-essential": '"@Development Tools"',
            "@development-tools": "",
        },
        "tpm": True,
        "selinux": True,
    },
    # ---- SUSE family ----
    "sle15sp6": {
        "family": "zypper",
        "image": "registry.suse.com/suse/sle15:15.6",
        "scc": True,
        "scc_vers": "15.6",
        "post_bootstrap": [
            # Python 3.6 doesn't have dataclasses; install python311 and symlink as python3
            "RUN zypper --non-interactive install python311 && ln -sf /usr/bin/python3.11 /usr/bin/python3",
        ],
        "replace": {
            "build-essential": "",
            "@development-tools": "",
            "dbus-devel": "dbus-1-devel",
            "tpm2-tss-devel": "tpm2-0-tss-devel",
            "sqlite-devel": "sqlite3-devel",
            "policycoreutils-devel": "",
            "selinux-policy-targeted": "",
        },
        "tpm": True,
    },
    "sle15sp7": {
        "family": "zypper",
        "image": "registry.suse.com/suse/sle15:15.7",
        "scc": True,
        "scc_vers": "15.7",
        "post_bootstrap": [
            # Python 3.6 doesn't have dataclasses; install python311 and symlink as python3
            "RUN zypper --non-interactive install python311 && ln -sf /usr/bin/python3.11 /usr/bin/python3",
        ],
        "replace": {
            "build-essential": "",
            "@development-tools": "",
            "dbus-devel": "dbus-1-devel",
            "tpm2-tss-devel": "tpm2-0-tss-devel",
            "sqlite-devel": "sqlite3-devel",
            "clang": "clang7",
            "policycoreutils-devel": "",
            "selinux-policy-targeted": "",
        },
        "tpm": True,
    },
    "sle16": {
        "family": "zypper",
        "image": "registry.suse.com/bci/bci-sle16-kernel-module-devel:16.0",
        "scc": True,
        "scc_vers": "16.0",
        "extra_prep": [
            # Temporary patch for broken SLE libudev1 version in the base image
            "RUN zypper in -y --oldpackage libudev1-257.7-160000.2.2.$(uname -m)",
            # Temporary authselect build, since it hasn't landed in PackageHub yet
            "RUN zypper ar -e https://download.opensuse.org/repositories/home:/dmulder:/branches:/authselect/16.0/home:dmulder:branches:authselect.repo",
            "RUN zypper --non-interactive --gpg-auto-import-keys refresh home_dmulder_branches_authselect"
        ],
        "replace": {
            "build-essential": "",
            "@development-tools": "",
            "dbus-devel": "dbus-1-devel",
            "tpm2-tss-devel": "tpm2-0-tss-devel",
            "sqlite-devel": "sqlite3-devel",
            "selinux-policy-targeted": "selinux-tools selinux-policy-devel",
        },
        "tpm": True,
        "selinux": True,
    },
    "tumbleweed": {
        "family": "zypper",
        "image": "opensuse/tumbleweed:latest",
        "extra_prep": [
            "RUN zypper ar -e https://download.opensuse.org/repositories/security:/idm/openSUSE_Tumbleweed/security:idm.repo",
            "RUN zypper --non-interactive --gpg-auto-import-keys refresh security_idm"
        ],
        "replace": {
            "build-effective": "",
            "@development-tools": "",
            "dbus-devel": "dbus-1-devel",
            "tpm2-tss-devel": "tpm2-0-tss-devel",
            "sqlite-devel": "sqlite3-devel",
            "selinux-policy-targeted": "selinux-tools selinux-policy-devel",
        },
        "tpm": True,
        "selinux": True,
    },
    # ---- Gentoo family ----
    # Gentoo generates an ebuild file instead of building binaries
    # Uses a lightweight Python image since no Gentoo-specific tools are needed
    "gentoo": {
        "family": "ebuild",
        "image": "python:3.11-slim",
        "extra_prep": [],
        "tpm": True,
        "selinux": False,
    },
    # ---- Amazon Linux family ----
    "amzn2023": {
        "family": "rpm",
        "image": "amazonlinux:2023",
        "extra_prep": [],
        "replace": {
            "build-essential": '"@Development Tools"',
            "@development-tools": "",
            "curl": "",  # avoid the curl/curl-minimal install conflict
        },
        "tpm": True,
        "selinux": True,
    },
}

DOCKERFILE_TPL = """\
{GENERATED_MARKER}{tooling_stage}FROM {base_image}

{env}
{sle_connect}

# Build argument for optional Cargo patch configuration
ARG CARGO_PATCH_ARG=""

# Install essential build dependencies
{bootstrap}
{post_bootstrap}
# Set environment for Rust
ENV PATH="/root/.cargo/bin:${{PATH}}"

# Project layout
VOLUME /himmelblau

# Change directory to the repository
WORKDIR /himmelblau


# Install Rust (latest stable) and packaging tools
{rust_install}

{patch_libhimmelblau}

{selinux_enabled}
# Build the project and create the packages
{final_cmd}
"""

# Minimal Dockerfile template for ebuild generation (no Rust needed)
DOCKERFILE_EBUILD_TPL = """\
{GENERATED_MARKER}FROM {base_image}

# Project layout
VOLUME /himmelblau

# Change directory to the repository
WORKDIR /himmelblau

# Generate the ebuild file
{final_cmd}
"""

# DEB cross-compilation Dockerfile template (amd64 host → aarch64 target)
# Uses Debian multiarch to install arm64 dev libraries alongside amd64 toolchain
DOCKERFILE_CROSS_DEB_TPL = """\
{GENERATED_MARKER}FROM {base_image}

{env}

# Build argument for optional Cargo patch configuration
ARG CARGO_PATCH_ARG=""

# Add arm64 architecture for multiarch cross-compilation
RUN dpkg --add-architecture arm64

{multiarch_sources}
# Install essential build dependencies (amd64 toolchain + arm64 libraries)
{bootstrap}
{post_bootstrap}
# Install aarch64 cross-compiler and arm64 dev libraries
# --force-overwrite: transitive deps (e.g. libcurl4-openssl-dev) may ship
# arch-independent files like /usr/bin/curl-config that conflict with the
# amd64 version already installed in the bootstrap step.
RUN apt-get update && apt-get install -y -o Dpkg::Options::="--force-overwrite" \\
    gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \\
    libssl-dev:arm64 \\
    libdbus-1-dev:arm64 \\
    libkrb5-dev:arm64 \\
    libpam0g-dev:arm64 \\
    libcap-dev:arm64 \\
    libudev-dev:arm64 \\
    libtss2-dev:arm64 \\
    libsqlite3-dev:arm64 \\
    libpcre2-dev:arm64 \\
    libunistring-dev:arm64 \\
    && rm -rf /var/lib/apt/lists/*

# Set environment for Rust
ENV PATH="/root/.cargo/bin:${{PATH}}"

# Project layout
VOLUME /himmelblau

# Change directory to the repository
WORKDIR /himmelblau

# Install Rust + aarch64 target + packaging tools (native amd64)
RUN --mount=type=cache,target=/root/.cargo/registry curl https://sh.rustup.rs -sSf | sh -s -- -y && \\
    rustup target add aarch64-unknown-linux-gnu && \\
    cargo install cargo-deb cargo-generate-rpm

# Configure cross-compilation
ENV CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc \\
    CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc \\
    CXX_aarch64_unknown_linux_gnu=aarch64-linux-gnu-g++ \\
    AR_aarch64_unknown_linux_gnu=aarch64-linux-gnu-ar \\
    PKG_CONFIG_PATH_aarch64_unknown_linux_gnu=/usr/lib/aarch64-linux-gnu/pkgconfig \\
    PKG_CONFIG_SYSROOT_DIR_aarch64_unknown_linux_gnu=/ \\
    PKG_CONFIG_ALLOW_CROSS=1

{patch_libhimmelblau}

{selinux_enabled}
# Build the project and create the packages
{final_cmd}
"""

# Rust install: native (amd64) — compile cargo-deb/cargo-generate-rpm from source
RUST_INSTALL_NATIVE = """\
RUN --mount=type=cache,target=/root/.cargo/registry curl https://sh.rustup.rs -sSf | sh -s -- -y && \\
    cargo install cargo-deb cargo-generate-rpm"""

# Rust install: emulated (arm64) — only install Rust itself, skip packaging tools
# cargo-deb and cargo-generate-rpm are cross-compiled in a separate amd64 stage
# CFLAGS=-O2: prevent gcc segfaults under QEMU emulation (gcc -O3 triggers QEMU bugs)
RUST_INSTALL_EMULATED = """\
ENV CFLAGS="-O2" CXXFLAGS="-O2"
RUN --mount=type=cache,target=/root/.cargo/registry curl https://sh.rustup.rs -sSf | sh -s -- -y
COPY --from=tooling /usr/local/cargo/bin/cargo-deb /root/.cargo/bin/cargo-deb
COPY --from=tooling /usr/local/cargo/bin/cargo-generate-rpm /root/.cargo/bin/cargo-generate-rpm"""

# Cross-compilation stage: build cargo-deb and cargo-generate-rpm for aarch64 on amd64
TOOLING_STAGE_TPL = """\
FROM --platform=linux/amd64 rust:latest AS tooling
RUN apt-get update && apt-get install -y gcc-aarch64-linux-gnu && rm -rf /var/lib/apt/lists/*
RUN rustup target add aarch64-unknown-linux-gnu
ENV CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
RUN cargo install --target aarch64-unknown-linux-gnu cargo-deb cargo-generate-rpm

"""

# Ubuntu codename mapping (used for multiarch apt sources)
UBUNTU_CODENAMES = {
    "ubuntu:22.04": "jammy",
    "ubuntu:24.04": "noble",
    "ubuntu:25.10": "plucky",
}

# Ubuntu 24.04+ uses DEB822 format (.sources files)
UBUNTU_DEB822_VERSIONS = {"ubuntu:24.04", "ubuntu:25.10"}


def build_multiarch_sources(dist_cfg):
    """Generate apt source reconfiguration for Ubuntu arm64 cross-compilation.

    Ubuntu serves arm64 packages from ports.ubuntu.com, not archive.ubuntu.com.
    Debian serves all architectures from the same mirrors, so no reconfiguration needed.
    """
    image = dist_cfg["image"]

    # Debian: no reconfiguration needed — deb.debian.org serves arm64 natively
    if not image.startswith("ubuntu:"):
        return ""

    codename = UBUNTU_CODENAMES.get(image)
    if not codename:
        # If a new Ubuntu version is added to DISTS but not to UBUNTU_CODENAMES,
        # warn loudly so the build fails visibly rather than silently skipping
        # multiarch configuration (which would cause cryptic apt 404 errors).
        print(f"[WARNING] No codename in UBUNTU_CODENAMES for {image} — arm64 apt sources not configured!")
        return ""

    if image in UBUNTU_DEB822_VERSIONS:
        # DEB822 format (Ubuntu 24.04+):
        # Pin existing sources to amd64, create separate arm64 sources file
        return f"""\
# Configure apt sources for arm64 cross-compilation
# Ubuntu serves arm64 packages from ports.ubuntu.com, not archive.ubuntu.com
RUN sed -i '/^Types: deb$/a Architectures: amd64' /etc/apt/sources.list.d/ubuntu.sources
RUN cat <<'EOF' > /etc/apt/sources.list.d/ubuntu-arm64.sources
Types: deb
URIs: http://ports.ubuntu.com/ubuntu-ports/
Suites: {codename} {codename}-updates {codename}-backports
Components: main restricted universe multiverse
Architectures: arm64
Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg

Types: deb
URIs: http://ports.ubuntu.com/ubuntu-ports/
Suites: {codename}-security
Components: main restricted universe multiverse
Architectures: arm64
Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
EOF
"""
    else:
        # Traditional sources.list format (Ubuntu 22.04):
        # Pin existing entries to [arch=amd64], append arm64 entries for ports.ubuntu.com
        return f"""\
# Configure apt sources for arm64 cross-compilation
# Ubuntu serves arm64 packages from ports.ubuntu.com, not archive.ubuntu.com
RUN sed -i 's/^deb http/deb [arch=amd64] http/' /etc/apt/sources.list && \\
    echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ {codename} main restricted universe multiverse" >> /etc/apt/sources.list && \\
    echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ {codename}-updates main restricted universe multiverse" >> /etc/apt/sources.list && \\
    echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ {codename}-backports main restricted universe multiverse" >> /etc/apt/sources.list && \\
    echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ {codename}-security main restricted universe multiverse" >> /etc/apt/sources.list
"""


SLE_CONNECT_TPL = """\
# Install SUSEConnect and dependencies for registration
RUN zypper --non-interactive refresh && \\
    zypper --non-interactive install --no-recommends \\
        SUSEConnect \\
        ca-certificates \\
        suse-build-key && \\
    zypper clean --all

RUN --mount=type=secret,id=scc_regcode,dst=/run/secrets/scc_regcode \\
    set -e && \\
    source /run/secrets/scc_regcode && \\
    SUSEConnect --email "$email" --regcode "$regcode" && \\
    SUSEConnect -p PackageHub/{scc_vers}/$(uname -m)
"""


def build_pkg_list(dist_cfg, selinux):
    fam = FAMILIES[dist_cfg["family"]]
    pkgs = list(fam["pkgs"])
    rep = dist_cfg.get("replace", {})
    out = []
    if selinux:
        pkgs += SELINUX_PKGS
    for p in pkgs:
        q = rep.get(p, p)
        if q:
            out.append(q)
    # Add any distro-specific extra packages
    extra = dist_cfg.get("extra_pkgs", [])
    out.extend(extra)
    out = sorted(set(out))
    sep = " \\\n        "
    return sep.join(out)


def render(dist_name, dist_cfg, patch_libhimmelblau, arch="amd64"):
    fam = FAMILIES[dist_cfg["family"]]
    selinux = bool(dist_cfg.get("selinux", False))
    pkgs = build_pkg_list(dist_cfg, selinux)
    # Handle bootstrap - some families (like ebuild) don't need package formatting
    if "{pkgs}" in fam["bootstrap"]:
        bootstrap = fam["bootstrap"].format(pkgs=pkgs).rstrip()
    else:
        bootstrap = fam["bootstrap"].rstrip()
    env = fam["env"] or ""
    sle_connect = SLE_CONNECT_TPL.format(scc_vers=dist_cfg.get("scc_vers")) if dist_cfg.get("scc") else ""

    # Features
    tpm = bool(dist_cfg.get("tpm", False))
    features = []
    if tpm:
        features.append("tpm")

    # Determine cross-compilation target for arm64 DEB builds
    arch_info = ARCH_MAP.get(arch, ARCH_MAP["amd64"])
    cross_target = arch_info["rust_target"] if arch != "amd64" else ""

    final_cmd = ""
    if dist_cfg["family"] == "deb" and dist_name != "test":
        final_cmd = build_deb_final_cmd(features, dist_name, cross_target=cross_target)
    elif dist_name == "test":
        final_cmd = "CMD cargo test"
    elif dist_cfg["family"] == "ebuild":
        # Ebuild generation - lightweight, just runs gen_ebuild.py
        repo_root = Path(__file__).parent.parent.resolve()
        final_cmd = build_gentoo_final_cmd(features, repo_root)
    else:
        final_cmd = build_rpm_final_cmd(features, selinux)

    blocks = []
    if dist_cfg.get("extra_prep"):
        blocks.extend(dist_cfg["extra_prep"])
    extra = "\n".join(blocks) + ("\n" if blocks else "")

    # Post-bootstrap commands (run after main package install)
    post_blocks = []
    if dist_cfg.get("post_bootstrap"):
        post_blocks.extend(dist_cfg["post_bootstrap"])
    post_bootstrap = "\n".join(post_blocks) + ("\n" if post_blocks else "")

    # DEB arm64: use cross-compilation template (no QEMU emulation)
    if arch != "amd64" and dist_cfg["family"] == "deb":
        multiarch_sources = build_multiarch_sources(dist_cfg)
        df = DOCKERFILE_CROSS_DEB_TPL.format(
            GENERATED_MARKER=GENERATED_MARKER,
            base_image=dist_cfg["image"],
            env=env,
            multiarch_sources=multiarch_sources,
            bootstrap=(extra + bootstrap),
            post_bootstrap=post_bootstrap,
            selinux_enabled=("ENV HIMMELBLAU_ALLOW_MISSING_SELINUX=1" if not selinux else ""),
            patch_libhimmelblau="COPY ./scripts/cargo-patch-config.toml /root/.cargo/config.toml" if patch_libhimmelblau else "",
            final_cmd=final_cmd,
        )
        return df

    # Select Rust install method and tooling stage based on architecture
    if arch != "amd64":
        # arm64 RPM/zypper: cross-compile packaging tools on amd64, copy into arm64 stage
        rust_install = RUST_INSTALL_EMULATED
        tooling_stage = TOOLING_STAGE_TPL
    else:
        # amd64: compile packaging tools natively
        rust_install = RUST_INSTALL_NATIVE
        tooling_stage = ""

    # Use minimal template for ebuild generation
    if dist_cfg["family"] == "ebuild":
        df = DOCKERFILE_EBUILD_TPL.format(
            GENERATED_MARKER=GENERATED_MARKER,
            base_image=dist_cfg["image"],
            final_cmd=final_cmd,
        )
    else:
        df = DOCKERFILE_TPL.format(
            GENERATED_MARKER=GENERATED_MARKER,
            tooling_stage=tooling_stage,
            base_image=dist_cfg["image"],
            env=env,
            bootstrap=(extra + bootstrap),
            post_bootstrap=post_bootstrap,
            sle_connect=("\n" + sle_connect + "\n" if sle_connect else ""),
            rust_install=rust_install,
            selinux_enabled=("ENV HIMMELBLAU_ALLOW_MISSING_SELINUX=1" if not selinux else ""),
            patch_libhimmelblau="COPY ./scripts/cargo-patch-config.toml /root/.cargo/config.toml" if patch_libhimmelblau else "",
            final_cmd=final_cmd,
        )
    return df


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--out", default="./dockerfiles", help="Output directory")
    ap.add_argument("--only", default="", help="Comma-separated list of dists to render")
    ap.add_argument(
        "--arch", default="amd64",
        choices=sorted(ARCH_MAP.keys()),
        help="Target architecture (default: amd64)",
    )
    ap.add_argument(
        "--patch-libhimmelblau",
        dest="patch_libhimmelblau",
        action="store_true",
        help="Patch libhimmelblau with a local copy mounted at /libhimmelblau",
    )
    ap.add_argument(
        "--no-patch-libhimmelblau",
        dest="patch_libhimmelblau",
        action="store_false",
        help=argparse.SUPPRESS
    )
    ap.set_defaults(patch_libhimmelblau=False)
    args = ap.parse_args()

    if args.only:
        want = {x.strip() for x in args.only.split(",") if x.strip()}
    else:
        want = set(DISTS.keys())

    os.makedirs(args.out, exist_ok=True)

    # For non-default arch, use arch-suffixed Dockerfile names
    arch_suffix = f".{args.arch}" if args.arch != "amd64" else ""

    written = []
    skipped = []
    for name in sorted(want):
        if name not in DISTS:
            print(f"[skip] unknown dist: {name}")
            continue
        # Check if this distro supports the requested architecture
        if args.arch != "amd64" and not DISTS[name].get(args.arch, True):
            skipped.append(name)
            continue
        df = render(name, DISTS[name], args.patch_libhimmelblau, arch=args.arch)
        path = os.path.join(args.out, f"Dockerfile.{name}{arch_suffix}")
        with open(path, "w", encoding="utf-8") as f:
            f.write(df)
        written.append(path)

    print(f"Wrote {len(written)} Dockerfiles (arch={args.arch}):")
    for p in written:
        print("  -", p)
    if skipped:
        print(f"Skipped {len(skipped)} distros (no {args.arch} support): {', '.join(skipped)}")


if __name__ == "__main__":
    main()
